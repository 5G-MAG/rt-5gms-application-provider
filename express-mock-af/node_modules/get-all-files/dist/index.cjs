var node_fs = /*@__PURE__*/require('node:fs');
var promises = /*@__PURE__*/require('node:fs/promises');
var node_path = /*@__PURE__*/require('node:path');

const getAllFilesSync = (filename, options) => {
  const normalizedOptions = normalizeOptions(options);
  const files = {
    *[Symbol.iterator]() {
      if (!node_fs.lstatSync(filename).isDirectory()) {
        yield filename;
        return;
      }
      yield* function* walk(dirname) {
        if (normalizedOptions.isExcludedDir(dirname)) {
          return;
        }
        for (const dirent of node_fs.readdirSync(dirname, {
          withFileTypes: true
        })) {
          const filename = dirname + dirent.name;
          if (dirent.isDirectory()) {
            yield* walk(filename + node_path.sep);
          } else {
            yield filename;
          }
        }
      }(normalizeDirname(filename, normalizedOptions));
    },
    toArray: () => [...files]
  };
  return files;
};
const getAllFiles = (filename, options) => {
  const normalizedOptions = normalizeOptions(options);
  const files = {
    async *[Symbol.asyncIterator]() {
      if (!(await promises.lstat(filename)).isDirectory()) {
        yield filename;
        return;
      }
      const dirnames = [];
      let filenames = [];
      const promises$1 = new Set();
      const walk = async dirname => {
        const promise = (async () => {
          if (normalizedOptions.isExcludedDir(dirname)) {
            return;
          }
          for (const dirent of await promises.readdir(dirname, {
            withFileTypes: true
          })) {
            const filename = dirname + dirent.name;
            if (dirent.isDirectory()) {
              dirnames.push(filename + node_path.sep);
            } else {
              filenames.push(filename);
            }
          }
        })();
        promises$1.add(promise);
        await promise;
        promises$1.delete(promise);
      };
      void walk(normalizeDirname(filename, normalizedOptions));

      // eslint-disable-next-line typescript/no-unnecessary-condition
      while (true) {
        await Promise.race(promises$1);
        if (filenames.length > 0) {
          const previousFilenames = filenames;
          filenames = [];
          yield* previousFilenames;
        }
        while (dirnames.length > 0) {
          void walk(dirnames.pop());
        }
        if (promises$1.size === 0) {
          break;
        }
      }
    },
    toArray: async () => {
      const filenames = [];
      for await (const filename of files) {
        filenames.push(filename);
      }
      return filenames;
    }
  };
  return files;
};
const normalizeOptions = ({
  resolve = false,
  isExcludedDir = () => false
} = {}) => ({
  resolve,
  isExcludedDir
});
const normalizeDirname = (dirname, options) => {
  if (options.resolve) {
    dirname = node_path.resolve(dirname);
  }
  if (dirname.length > 0 && dirname.at(-1) !== node_path.sep) {
    dirname += node_path.sep;
  }
  return dirname;
};

exports.getAllFiles = getAllFiles;
exports.getAllFilesSync = getAllFilesSync;
